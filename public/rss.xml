<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/">
    <channel>
        <title>ifu's Blog</title>
        <link>https://ifuxyl.dev</link>
        <description>Homebase [to] -- serving articles &amp; blogs, for ifu.</description>
        <lastBuildDate>Fri, 04 Oct 2024 00:17:02 GMT</lastBuildDate>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
        <generator>Feed for Node.js</generator>
        <language>en</language>
        <image>
            <title>ifu's Blog</title>
            <url>https://ifuxyl.dev/favicon.png</url>
            <link>https://ifuxyl.dev</link>
        </image>
        <copyright>All rights reserved 2024, ifu</copyright>
        <item>
            <title><![CDATA[An Outsider's Queerness]]></title>
            <link>https://ifuxyl.dev/blog/an-outsider's-queerness</link>
            <guid>https://ifuxyl.dev/blog/an-outsider's-queerness</guid>
            <pubDate>Wed, 25 Sep 2024 00:00:00 GMT</pubDate>
            <description><![CDATA[An exploratoration on the definition and role of an outsider, and how that emerges as pseudo-queerness, especially amongst the LGBTQ+.]]></description>
            <content:encoded><![CDATA[
I remember a conversation I had with a close friend back in high school. She asked why I never opened up to her, depsite being friends since elementary. I thought I've always did-- I told her jokes, talked about my day, my homework, and played games with her.
Wasn't that the core essence of a friendship? I realize it wasn't enough for her. What I show to her, externally, must delve deeper into the sea of my psyche. I would have to show **vulnerability**, because to be vulnerable is to trust. Trust is important because it's a marker to show how important they are to you, and it directly affects your actions & behaviors with them.

I realize by not showing that with her, I was "untrusting". But, I wanted to respond with my own question. I couldn't find the words and at that point, she left the conversation.
I never talked to her again, and I wish I could've put her at ease.
At the end, I remembered what I wanted to ask her:

"How can I be vulnerable if I've never been vulnerable to myself?"

# "It's just introversion."

I'm a pretty quiet person. I don't speak much, and I don't like to overshare to people I don't know. In other words, I keep to myself a lot. People have similar experiences, and they colloquially refer to this behavior as "introversion".

I liked that word because it made me feel less alone. I was able to associate my identity & character with a single, definable word. And instead of having to justify every aspect of myself on each encounter, I can simply say: "I'm just an introvert".

But, I have a hard time trusting others. I can't bring myself to forge meaningful relationships because of my reluctance to trust. And yet, I loathe superficiality.

Recently, I've met a couple of people my age. They were the perfect match for me: calm, down-to-earth, conscientous of the world, and most importantly, accepting. I found myself beaming as we talked about random topics & experiences in our lives, and I left it smiling shamelessly at how euphoric it was. I realize I might not be an introvert, or more specifically, "just" an introvert. It's not binary. It's not this or that. It's easy to treat it like zeroes and ones, but my true, authentic self requires something in the middle. It requires something that introduces external variables, possibilities, context, or anything that can constitute who I am.

## Living in Binary

You're either a man or a woman. You're either masculine or feminine. You're either a dog lover or a cat lover. You're either a Democrat or a Republican.

Binary is a system that represents information in two symbols, a one or a zero. Arbitrarily, the symbols' exact definition doesn't matter, but they must be different. In another way, it's like making a decision: "this" or "that".

We treat our identities as binary choices. I called myself an introvert because I was **_not_** an extrovert. I called myself a dog lover because I love dogs more than cats. I'm a man because I can't be a woman.

In conversation, we're racing around the clock to get to know each other. Historically, the easiest way to convey yourself to others is through binary labels. We think of our character as a checklist to compare ourselves with others. Once we enter later stages in our relationship, we can then unfold the binary labels to the truest element of ourselves.

But paradoxically, the present is valuable. To spend every minute grounded in the present, even if we're "running out of time" is inexpicably beneficial. It's nice to have labels, but relationships build by stripping that away. Everybody is uniquely their own, and labels only obfuscate that self from others. To live without binary is to truly be free.

## What is Queerness, to me

I'm a very different person than most people think I am. People have told me they imagined me to be much **more** feminine because of my mannerisms on a given day. Others have imagined me to be short and scrawny, and that my appearance doesn't match my personality. My closest friends can sometimes be shocked when my temperament is much more laid-back and nonchalant, since I tend to be more animated when I get to see them every day.

In other aspects of myself, people think I'm a bookworm, so they're surprised I'm above average in high-octane competitive games. They assume I'm "default smart", and they're alarmed when I display intense frustration in my clumsiness & inaptitude.

These things don't register as expected because it comes with the territory of getting to know someone. You start to unravel these layers that made up your perception of them, and it's up to you to ultimately decide if it affects you or not.

But there's also the intrinsic part of the "unexpectedness" with our true selves. I've once demonized myself for being different. I look up to others who are that version of me I'm trying to convince others I am. But through rose-colored glasses, I only hurt myself by not embracing the "bad" parts about me. What I show externally is my own need to be perceived as. I want to look smart, I want to be feminine, I want to be the "token gay".

But, I'm not. I'm just me. I used to say that with disdain, but now it's become empowering. I am me, and nobody else but me.

Queerness is the expression of the true self. It's a violation of the binary, and an embrace in the spectrum. It takes what was the default, and unravels it to a myriad of possibilities. It's an exploration towards self-discovery, because to discover oneself is to abolish the rules that bound you to a lesser form. Queerness is the sound of doors opening. Queerness is freedom.

I think I am gay. I'm attracted to the same-sex, but I also love fictional women. I used to have female crushes, but I definitely have male ones. But, I think I am gay and that truth is my own. There's no definition of being gay, much like how there's no definition on being "smart". It's subjective, complicated, difficult, and ultimately pointless. Because it's just a part of you, it's not a fact or requires reason or needs special attention. It's pointless to debate because it's the undeniable truth.

So, a fact about me is: I am gay, and I have a story to tell.

## Coping without Solace

There's a [documentary](https://youtu.be/6VduIJPAHaQ?si=yunfkjWMoCGpTzQQ) addressing a large-scale issue amongst queer people called **"queer loneliness"**. I highly recommend taking a look, since it's extremely validating for those in queer spaces. We are entering a new era that openly accepts queerness to seep into facets in our life, but it is a long way from becoming the new normal. Video games I regularly play advocate for queer diversity, movies I watch are now introducing queer issues, and social media influencers have come forward as fellow queers and/or advocates for the LGBTQ+. It's definitely easier to be queer, but we can't rely on others to feel safe in our skin.

Those who aren't queer, those who have a good career, a loving family, a roof over their heads-- they do not have to prove to others to be happy. They are comfortable with who they are because they are our society's definition of normal. When we start associating outside of this normal, we treat ourselves as "less". A person that is different is a person who is **not** normal. We call these people "outsiders".

It's not just physical differences, but even mental ones. Our need to feel connected to others take priority over our need to be ourselves. Why have your own political ideas when you can lean to a specific party? Why have opinions on how to live your life when you can emulate the life of someone else? Why complicate yourself when being similar to others will make you feel less uncomfortable?

This isn't strictly an internal battle. Many people face struggle from outward backlash and biases from others. We use stereotypes to categorize people we don't know, and to make our judgements on someone despite barely being introduced to them.

However, no one is coming to save us. We only truly have ourselves, and we have to give ourselves the respect we deserve when no one else can.

But to be comfortable, we need to respect our intuition. The choices we make-- the lives we decide to live-- is uniquely our own. In my experience, I felt like I was chasing for a goal I never truly wanted. It stems from envy of others who seem more successful and more accomplished. [Workaholism](https://www.youtube.com/watch?v=iAMzp-jFymY) is a manifestion of our need for success, regardless of our goals. It's obsession for more, not a journey to self-realization. I had to revisit my values, my goals, and be satisfied regardless if anyone agreed with me.

It's lonely, definitely, but it is not permanent. As the world changes, we change too. We will find our people, we will find that solace, but they're not waiting for us. We have to fight our battles, learn to channel positivity in ourselves, and seek out others who can carry that same love.

# About me, really

I'm not looking for much. I'm a modest person, and I don't need to be someone "great". Throughout my life, I've let my insecurities affect how I perceive being average. The middle of the bell-curve, where everyone mostly exists, was frightful to me. Being special means being unlike others, and I desired that. But, I'm constantly criticized for being different-- I hated myself because I was different. Why am I chasing for a world of solitude when I've always been eagerly waiting for real connection?

Now, I like the word "average". An average is an expected metric, so others can align themselves with that metric. I want to live a happy, no-nonsense life. I want to live modestly, to live within my means, and to be comfortable in my skin.

But, to be average means I'm yet to achieve the top. I want to always learn, to always grow. I want to be on my deathbed, still in the pursuit of learning. Learning is what makes me truly happy, from learning who I am, learning my values, learning to understand others, learning to fight for my truth, it all culminates into my sense of self. Average was never a deterrent to strike your inferiority, but an invitation to be ourselves with every good, bad, and ugly.

There is societal pressure to not be average, but there's no need to prove ourselves to others. It's a false truth to seek validation other than from ourselves, and I've learned to break that notion because it only invites hatred.

Extraordinary people are below-average in other aspects, there is no such thing as a "king-of-all-trades". We live in a world where we rely on extraordinary people in trades, but anyone can tell you that their value in others is subjective. Why bother comparing two beautiful, delicious cakes when we can simply eat both? There is room for you, there is opportunity for you, and you don't need to be anything else than to exist.

Your existence is already enough, because you are beautiful.

--

You've reached the end, thank you for reading.
To stay notified, consider checking out my [RSS](https://ifuxyl.dev/rss.xml) to be notified of articles like this-- it may be worth your time!

Have a comment, question, or an ask? Feel free to [email](mailto:sweeneyngo@proton.me) me!
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Acronyms and Markov Chains]]></title>
            <link>https://ifuxyl.dev/blog/acronyms-and-markov-chains</link>
            <guid>https://ifuxyl.dev/blog/acronyms-and-markov-chains</guid>
            <pubDate>Sun, 15 Sep 2024 00:00:00 GMT</pubDate>
            <description><![CDATA[Learning to associate sentence creation and password memorization, and connecting these two ideas together.]]></description>
            <content:encoded><![CDATA[
I've been dealing with data breaches where my password was exposed-- a recent data breach was even localized at my own university.

As a result, Iâ€™ve revisited old accounts and changed their passwords to auto-generated hashes. I started using [Bitwarden](https://bitwarden.com/) as my main password manager, and Iâ€™ve found it easier to integrate its services with my devices compared to LastPass.

However, if someone were to force me to remember any of my passwords, I wouldnâ€™t be able to recall them. While Bitwarden is a useful tool, there are times when I need to come up with a strong, complex password that can withstand [brute force attacks](https://www.keepersecurity.com/threats/brute-force-attack.html). [Common passwords](https://en.wikipedia.org/wiki/List_of_the_most_common_passwords) are notorious for being easy to guess, either because they follow typical patterns or are tied to personal information (e.g., birthdays, years, names).

To improve security, many people opt for [passphrases](https://en.wikipedia.org/wiki/Passphrase).These are sequences of words that are easier to remember while being very naturally long (at the word-granularity). For instance, one can remember 4 words of 4 letters each much more easily than a 16-character password.
Passphrases are beneficial because they can be long and have high entropy, making them resistant to brute force attacks. However, if the passphrase is too comprehensible, it may still be susceptible to guessing based on common associations.

For example, "Cats play with yarn" is easy to guess because cats are commonly associated with yarn.

Even worse, attackers can use [dictionary attacks](https://en.wikipedia.org/wiki/Dictionary_attack) which reduce the entropy to the level of individual words, making the passphrase as vulnerable as a simple password.

So, how can we achieve both the ease of remembering passphrases and the high entropy of complex passwords?

# Motivation

The key idea is to use "semi-comprehensible" sentences. These sentences are easier to remember than random phrases but don't have a direct connection to personal information, making them harder for attackers to guess. With the words loosely connected, the user can recite them as they would an acronym.

With acronyms, like PEMDAS or HOMES, it's much easier to remember them through [mnemonic devices](https://www.masterclass.com/articles/mnemonic-devices-explained) than the original acronym. PEMDAS can be recited as "Please Excuse My Dear Aunt Sally" which is somewhat coherent, but is not connected to the original acronym.

Similarly, using uncommon, loosely connected words to create a passphrase can serve as a mnemonic device. This approach avoids the direct association with personal information, forcing attackers to rely on brute force methods.

# What are Markov Chains?

To put it simply, it's a state machine. Let's assume we're forcasting the weather.

The current weather can alternate between sunny, windy, cloudy, etc. We can think of these as **"states"**. So, let's assume that the current state of the weather is sunny. If we see a raincloud approaching, we can assume that the weather can transition to a rainy state. However, we cannot be certain, as weather relies on probability.

A sunny weather can just as easily remain sunny, change to rainy, or even cloudy. We refer to this probability of change as **"transitions"**.

![Markov chain](https://healeycodes.com/_next/image?url=%2Fposts%2Fgenerating-text-with-markov-chains%2Fweather-markov-chain.png&w=640&q=100)

From this diagram, a sunny weather has a 90% change of being sunny, and a 10% change of being rainy.

Note that a Markov chain doesn't necessarily scale with time or any metric that increases over time. More specifically, a Markov chain helps compute the next step based on the current state.

## Creating passphrases

How does this relate to creating passphrases? We can model a sentence as a sequence of words transitioning from one to another.

For example, "A cat with a hat" can be mapped out as:

```text
A -> cat -> with -> a -> hat
```

However, you may notice that the transitions will have a 100% chance of occurring. This is correct behavior since we expect that if we start with the word "A", we can determine that the next word must be "cat".

As we increase the number of sentences, the probability distribution becomes more diverse. We'll start seeing identical words mapping to different words.

For example, "A frog with a hat" will allow "A" to transition to either "cat" or "frog", each with a 50% probability.

As we scale up with more sentences, we build a probability model for word transitions.

The collection of sentences or text used to build this model is called a corpus. With this corpus, we can generate new sentences by starting with a word and choosing the next word based on probabilities.

As a result, you'll have a sentence that may resemble phrases in literary works, text, and/or documents in the English language, but avoids mimicking it entirely.

```go
futureWords, ok := markovChain.Transitions[currentWord]
if !ok || len(nextSentence) == 0 {
	return passphrase
}

nextWord = futureWords[rand.Intn(len(futureWords))]
```

As you can see, we want to get all the possible future states from our current word, then choose at random from these future states the next word to add on to our passphrase. If we reach a potential endword (no future states), then we can return our passphrase.

To find starting words, we can (1) use capitalized words in the corpus or (2) maintain a separate list of start words. Hereâ€™s an example of using the latter approach:

```go
func (m *MarkovChain) addSentence(sentence string) {

	words := strings.Fields(sentence)
	length := len(words)

	if length > 0 {
		startWord := words[0]
		m.StartWords[startWord] = true
	}
	// ...
}

func (m *MarkovChain) getRandomStartWord() string {

	var startWords []string
	for word := range m.StartWords {
		startWords = append(startWords, word)
	}

	return startWords[rand.Intn(len(startWords))]
}

```

## Building the password

To create a password from the passphrase, we can use the first letters of each word to form an acronym. To further complicate it, we can introduce "noise" by adding random symbols or numbers to the acronym. This makes it harder to remember but maintains the association with the original passphrase.

```go
func CreatePassword(sentence string, capLevel int, noiseLevel int) (string, error) {

	words := strings.Fields(sentence)
	acronym := CreateAcronym(words)
	noisyAcronym, err := addNoise(acronym, noiseLevel)

	return strings.Join(noisyAcronym, ""), nil
}
```

## Improvements

We can enhance the quality of our passphrases by using multi-word states instead of single words. For instance, "A tree" provides more context than just "A", leading to richer phrase possibilities.

Increasing the corpus size and incorporating diverse texts can also improve the generated passphrases. Iâ€™m continuously working on this to refine the results of my Markov chain implementation.

For my implementation, I've built a server running the Markov chain + passphrase generation in [Go](https://go.dev/). The frontend client application was developed in Typescript + [React](https://react.dev/) and built with [Vite](https://vitejs.dev/).

You can try it out through [this link](https://www.ifuxyl.dev/akro)!

![A screenshot of akro](https://i.imgur.com/Jf5Fueu.png)

# Sources

All resources, whether for learning or information, are sourced here. Most of the images & diagrams I've used can be found through these websites. Please take a look at them! Without the wealth of knowledge from these articles, I wouldn't have arrived at the solution for this particular project.

Andrew Healey's Generating Text with Markov Chains -- [https://healeycodes.com/generating-text-with-markov-chains](https://healeycodes.com/generating-text-with-markov-chains)

Markov Chains Explained Visually -- [https://setosa.io/ev/markov-chains/](https://setosa.io/ev/markov-chains/)

--

You've reached the end, thank you for reading.
To stay notified, consider checking out my [RSS](https://ifuxyl.dev/rss.xml) to be notified of articles like this-- it may be worth your time!

Have a comment, question, or an ask? Feel free to [email](mailto:sweeneyngo@proton.me) me!
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[The Hidden Beauty of HashLife]]></title>
            <link>https://ifuxyl.dev/blog/conway-hashlife</link>
            <guid>https://ifuxyl.dev/blog/conway-hashlife</guid>
            <pubDate>Wed, 04 Sep 2024 00:00:00 GMT</pubDate>
            <description><![CDATA[Discovering the iconic algorithm for the popular zero-player game, Conway's Game of Life.]]></description>
            <content:encoded><![CDATA[
I was introduced to Conway's Game of Life from Daniel Shiffman, particularly in his [mini-series](https://youtu.be/tENSCEO-LEc) about cellular automata. For those who are unaware, Conway's Game of Life was the product formed by rules devised by John Horton Conway in 1970. Despite its name, the Game of Life is a "zero-player game" where the game progresses without any player input. If anything, it's more appropriate to call it a "simulation".

Given a 2D grid, each cell can either be alive (1) or dead (0). What determines whether they live or die at each iteration are determined by the rules of the game.

The rules are as follows:

- Any living cell with less than two live neighbours dies ("underpopulation").
- Any living cell with more than three live neighbours dies ("overpopulation").
- Any dead cell with exactly three live neighbours will come to life.
- All other cells remain the same ("stasis").

![http://natureofcode.com/book/chapter-7-cellular-automata/](https://notes.huy.rocks/posts/img/game-of-life-visual.png)

To initiate the game, a configuration of cells in any shape, form, etc. is placed on the 2D grid. For each generation, the cells apply the above rules, changing their configuration throughout time.

It is undeniably a compelling thought experiment, as it proves that organization can emerge from a universe governed by very simple laws. Our civilization, culture, and species may very well be a result of eons of configurations that seem amorphous in nature, but can form meaningful constructs given a starting point & time.

For my implementation, I've decided to create my own simulation of Conway's Game of Life. The application was written in Typescript + [React](https://react.dev/) and built with [Vite](https://vitejs.dev/).
I've also implemented the main update loop with the [HashLife](https://en.wikipedia.org/wiki/Hashlife) algorithm (quadtrees & memoization), which we will discuss more thoroughly later in this article.

Currently, it supports edit mode, infinite canvas, zoom & pan, pattern import, and step size & speed. You can play with it yourself through [this link](https://www.ifuxyl.dev/seagull).

![Screenshot of my web implementation](https://i.imgur.com/isjQn9z.png)

Besides the introduction, the crux of this article will focus on Bill Gosper's [HashLife](https://en.wikipedia.org/wiki/Hashlife) algorithm, where we will discuss the definition, properties, implementation, and the hidden beauty that emerges from it.

# What is HashLife?

**Simply put, it is a memoization algorithm to compute long-term fate of a configuration.**
For instance, you can quite easily generate a 6,366,548,773,467,669,985,195,496,000 (6 [octillionth](https://en.wikipedia.org/wiki/Names_of_large_numbers 'Names of large numbers')) generation of a [Turing machine](https://en.wikipedia.org/wiki/Turing_machine 'Turing machine') in [Life](https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life "Conway's Game of Life").

If I were to give it a more descriptive title, one that explains exactly what it accomplishes, it would be: ["Exploiting Regularities in Large Cellular Spaces"](https://usr.lmf.cnrs.fr/~jcf/m1/gol/gosper-84.pdf).

In all walks of life, redundancy is everywhere. Whether you wake up in the morning to brush your teeth, or meeting up with the same clique of friends, or even communing to work, we carry ourselves through the "ordinary". Our brains can even remember when we've done something again, such as when we encounter a hard math question that we've studied the night before, or learning a new language, and we can use our memory to guide us towards the answer.

Through redundancy, we can achieve memory, and through memory, we can arrive at the solution with less time & resources from the first time we've attempted it.

In computer science, this principle holds true. We use code to automate everything in our lives, because a computer can tolerate the endless repetition of a task. But, if we allow the computer to remember a task, the computer can more efficiently arrive at a solution much like humans.

When iterating through each generation of Conway's Game of Life, there will be some sections of the grid that have recognizable patterns. For example, the Breeder 1 is composed of multiple Gosper glider guns, which can then generate smaller spaceships.

In fact, most large & complex configurations are mostly smaller configurations working in unison, so if we can somehow "remember" how a portion of it changes, we can assemble these changes back up to the large configuration, effectively updating the configuration entirely.

To summarize, we need to:

- Break down a configuration to smaller, recognizable configurations.
- Remember the state of that configuration, and quickly arrive at the changed state of that configuration.
- Reassemble the original configuration through these smaller resulting changes.

For the first step, we will use Quadtrees.
For the second step, we will use memoization. And finally, the last step will be accomplished by using these two strategies to build up to our final solution.

## Algorithm

For a more general overview, the algorithm stores subpatterns (we will refer to them as "subgrids", or even nodes) in a hash table (like a "cache"). Then, we memoize future iterations at various locations on the grid & time.

It works asynchronously â€” at any given moment it will usually have evolved different parts of the pattern through different numbers of generations.

The algorithm doesn't come without its drawbacks. For instance it's a very memory intensive implementation, since it has to potentially create multiple versions of the grid to cache the results. As such it is not suitable for showing a continuous display of the [evolution](https://conwaylife.com/wiki/Evolution 'Evolution') of a pattern. Moreover, HashLife performs poorly on highly chaotic patterns, since there is nothing for it to memorize, so switching to other alternatives like [QuickLife](https://conwaylife.com/wiki/QuickLife) are preferred.

We'll first focus on (1) reducing space via Quadtrees, then move to (2) reducing time via memoization. There will also be a section on achieving Hyperspeed using properties discovered through the algorithm's implementation.

# Reducing Space

## Redundancy in Patterns?

After exploring CGOL for some time, you may notice that there are "repeating" configurations (e.g. oscillators + still-lives).
One step further, consider how large patterns can lead to subpatterns that appear in several places, possibly at different times. **This** is what Hashlife answers.

## Quadtree

A quadtree is a tree with exactly four nodes.
Similar to a binary tree, quadtrees are often used for automata + image manipulation.

We can think of a quadtree as quadrants on a 2D grid. When we think of a graph, we know that there are four quadrants that surround the X-Y axis. Think of each quadrant as its own subgraph. From here, each subgraph has its own quadrants, leading to subgraphs within subgraphs, and you get the idea.

We can visualize this example through this:

![Quadtree of a 16x16 grid](https://www.dev-mind.blog/wp-content/uploads/2020/05/quadtree1-1024x839.png)

In quadtrees, graphs/grids are referred to as nodes. Treat every node as it's own "configuration grid". Notice how each node holds a portion of the configuration of its parent node. Each level of the graph decreases by one as you move down the graph:

- For example, a level 1 node is a 2x2 grid.
- For example, a level 2 node is a 4x4 grid.
- For example, a level 3 node is a 8x8 grid.
- Notice that each new level can fit four nodes of the previous level. A level 2 node's 4x4 grid can hold exactly four 2x2 grids, or exactly four level 1 node.
- At level 0, it contains the exact pixel, or 1x1 grid.

## Optimizations

Notice that in the previous representation of our quadtree, many nodes look exactly the same. This is a problem, because it's _exhaustive_-- we're not reusing these nodes, so we're actually increasing our space then decreasing it. Since the naive implementation uses the entire 2D grid to represent our configuration, we're not beating it in memory size. In fact, we store the 2D grid at the root node, **in addition** to the many subnodes under the quadtree. Therefore, we need some way to **compress** the tree so this tree representation can be more viable than a 2D grid.

We'll start by stating some observations from building out the exhaustive version of the quadtree:

**1. In level 0, a 1x1 grid can only be black or white. Therefore, there are only two nodes at level 0.**

- Furthermore, a 2x2 grid can only have 2^4 configurations, so there are only 16 nodes at level 1.
- Formulating this, the number of nodes is 2^(2^k \* 2^k), where k is the level.
- Obviously, the number of configurations skyrockets as we move up the graph, but it is important to understand how small & feasible the lower levels are. In fact, we can consider them as "building blocks", or more formally "cardinal nodes".

**2. The number of specific grids occuring is much lower.**
This is true, and we should NOT exhaust all possible grids. Therefore, we can treat the above optimization as a hard limit.

**3. To maximize sharing a common grid, only create one instance of that grid in our quadtree.**
As you may observe from the image, there are 3 out of the 4 quadrants of the 8x8 grid that are exactly the same. If instead of creating a new node for each quadrant, we just simply point to one instance of that subnode, we can significantly decrease the amount of subnodes we create. Moving further, we can keep abusing this principle to decrease the size of our quadtree.

For the application, we can use hashing to map any grid to an existing grid on the quadtree, avoiding creating duplicates.

Below, each level may have subgrids that are already memorized by the previous level. For instance, the level 3 node has **three** subgrids that match the left level 2 node, and **one** subgrid that match the right level 2 node. This is our ideal quadtree-- **tightly compressed**!

![Same original 8x8 grid, but as compressed quadtree.](https://www.dev-mind.blog/wp-content/uploads/2020/05/quadtree2-975x1024.png)

## Why not other implementations?

**Simple implementation**:

At each generation, use the neighbors of a cell to compute the next state.

**_Why is this bad?_**

It's O(kn), where n is the number of cells. Therefore, as we increase the number of cells, the algorithm will have to update every cell by a constant factor k. So, for sextillion cells, we'd have to make multiple sextillion updates!

Moreover, the representation of our grid is, well a grid! While it is the most intuitive way to represent our problem, there is no room to compress it, **especially** when we're encountering repetition that our grid just doesn't account for. Instead, we want to abuse pointers & caching in our representation, leading to the "quadtree".

_Aside: Why representation is important_:

Representation is key to reducing space.
Remember, space is memory, and our desktop can only handle so much memory.
For instance, "00000000" can be represented as "8#0" which is a smaller string!

For a "_very dumb_" example, if our grid was a 100x100 grid of all zeroes, then we can represent it as (100, 100, 0) instead of a 100x100 grid, reducing our space considerably.

That's why it's so important to focus on **representation**. It allows us to reduce a ridiculous amount of space to a smaller one, which can massively improve performance.

**The Quadtree division**:

![Cardinal directions for the four branches of a node.](https://i.imgur.com/pI93ux2.png)

With this representation, each of the four quadrants represents (nw, ne, sw, se). We can represent each grid as a `Node`, which we will showcase here:

```typescript
class Node {

    /*
     * Four quadrants of a node.
     *
     *      nw, ne,
     *      sw, se
     *
     * At level one, each quadrant is either (0, 1).
     */

    nw: Node | number;
    ne: Node | number;
    sw: Node | number;
    se: Node | number;

    // Current level of the node in the quadtree.
    level: number;

    constructor(
        nw: Node | number,
        ne: Node | number,
        sw: Node | number,
        se: Node | number
    ) {
        this.nw = nw;
        this.ne = ne;
        this.sw = sw;
        this.se = se;

        this.level = 0;

        if (typeof nw === "number" &&
            typeof ne === "number" &&
            typeof sw === "number" &&
            typeof se === "number"
        ) {
            this.level = 1; // 2x2
        }
        else if (
            nw instanceof Node &&
            ne instanceof Node &&
            sw instanceof Node &&
            se instanceof Node
        ) {
            this.level = nw.level + 1;
        }
    }
```

You'll notice that if the quadrants are at level one, they'll be a 1x1 grid of either 0 or 1, so we can represent them as a number rather than an entire Node. This distinction is useful to label each level, which you can see in our constructor.

Once we have the root node of a quadtree, we can now recursively update each level on the quadtree.

For example, given the 4x4 grid, we would have to compute directly on it, wasting time.
Instead, we can segment the 4x4 grid to a "quadtree", breaking it down to smaller chunks.
Then, we can work on the smaller chunks, and reassemble the 4x4 grid with the new updates ("divide-and-conquer").

In other words, we can represent any possible grid of any size down to a series of **canonical blocks** with a fixed set of configurations. For instance, we can choose the 2x2 grid to be our canonical block. Therefore, we consider all the possible 2Ã—2 cell blocks, leading to 16 possible 2Ã—2 blocks. With this, we perform the quadtree division until we reach lots of 2Ã—2 blocks, then reconstruct the original matrixes with the updated versions of those 2x2 blocks.

ðŸŸ¥ **Hold on.** Isn't this no better than just working on the original grid?

Since we will **already know all the possible updates** of 16 2x2 blocks, we can just cache it in memory, and reuse them instead of computing the update ourselves. Therefore, we're working on a substantially smaller, compressed tree rather than the full grid.

```javascript
function evolveNode(node) {
  if (node.level < 2) throw new Error('Current level cannot be less than 2.');
  if (
    !(
      this.nw instanceof Node &&
      this.ne instanceof Node &&
      this.sw instanceof Node &&
      this.se instanceof Node
    )
  )
    throw new Error('Current node cannot be at depth 1.');

  let resultNode;
  if (node.level === 2) {
    // Evolve via simple implementation.
  } else {
    resultNode = constructNode(
      evolveNode(node.nw),
      evolveNode(node.ne),
      evolveNode(node.sw),
      evolveNode(node.se),
    );
  }

  return resultNode;
}
```

ðŸŸ¥ **Hold on**. Won't the neighbors of any given node affect that node? In other words, is it feasible to run `evolveNode()` on the quadrants independently if they share neighbors between the quadrants?

Yes the neighbors will affect the node, so we will have to strategize some alternative solutions. The key idea is that **updating the entire node** is impossible without information from other nodes.

_Alternative solutions_:

- Consider the neighbor's contents towards updating a node -> _redundant_
- Pass the neighbor's pointers.
- **Create a center node**. Each result of `evolveNode()` will return a subgrid, one level lower, centered at the original grid. For example, a 8x8 grid will return a 4x4 grid centered at the original 8x8.

**Why doesn't Solution #1 or #2 work?**

We would not be reducing the time if we incorporate all the neighbors when evolving a grid, so we need a solution that evolves a subgrid independently from its neighbors. Therefore, our solution must meet the **original purpose** at all costs.

Moreover, we don't need all of the neighbor's information. We just need enough so that each pixel on the grid has all eight neighbors.

With the third solution, we realize that the maximum possible subgrid that allows all eight neighbors for every cell is the center subgrid. In fact, the simplest subgrid to work on is the center subgrid.

Therefore, we will focus on Solution #3.

**The result of evolve(node) will produce a center subgrid, one level down.**

![Center subgrid inside the original grid](https://i.imgur.com/RijDZAU.png)

When we recurse, each subgrid will calculate its own center grid, which we can see in green.

![Center subgrids recurse to form subgrids](https://i.imgur.com/NhBKBdw.png)

We haven't considered the edges of the center grid, because we simply don't need to! Consider a fixed grid for Conway's Game of Life. On the edges of the grid, these cells cannot be determined, since they lack all eight neighbors to determine whether they can live or not.

To put it more rigorously, we CANNOT determine the result of the edges of the grid without the information found outside of the given grid. Since we are strictly working independently with our grid, we focus on determining the center grid, as we can guarentee the correct result.

When implementing, it's crucial the quadtree accomodates for the entire configuration. If the root node has edge cells that are active, then the tree is not sufficiantly large enough and must expand to accomodate for those cells.

However, notice how we can't construct the blue center grid with the green center grids because they're not completely aligned. Only a quarter of each green center grid fits in the center blue square. We're only capturing the corners of the blue center grid.

Looking closer, it may be feasible to construct the blue square if we found multiple green center grids that outline the perimeter of the blue square. This observation paves the way for the "nine auxillary squares" strategy.

### Nine auxillary squares

![Nine auxillary squares](https://www.dev-mind.blog/wp-content/uploads/2020/05/center_comput.png)

```javascript
// Second version.
function evolveNode(node) {
  if (node.level < 2) throw new Error('Current level cannot be less than 2.');
  if (
    !(
      this.nw instanceof Node &&
      this.ne instanceof Node &&
      this.sw instanceof Node &&
      this.se instanceof Node
    )
  )
    throw new Error('Current node cannot be at depth 1.');

  let resultCenterNode;
  if (node.level === 2) {
    // Evolve via simple implementation.
  } else {
    const n00 = node.nw.centerNode();
    const n01 = node.nw.centerHorizontalNode((east = this.ne));
    const n02 = node.ne.centerNode();
    const n10 = node.nw.centerVerticalNode((south = this.sw));
    const n11 = node.centerNodeNode();
    const n12 = node.ne.centerVerticalNode((south = this.se));
    const n20 = node.sw.centerNode();
    const n21 = node.sw.centerHorizontalNode((east = this.se));
    const n22 = node.se.centerNode();

    resultCenterNode = assembleNineNode(
      evolveNode(n00),
      evolveNode(n01),
      evolveNode(n02),
      evolveNode(n10),
      evolveNode(n11),
      evolveNode(n12),
      evolveNode(n20),
      evolveNode(n21),
      evolveNode(n22),
    );
  }

  return resultCenterNode;
}

function centerNode() {
  return this.constructor.constructNode(
    this.nw.se,
    this.ne.sw,
    this.sw.ne,
    this.se.nw,
  );
}

function centerHorizontalNode(east) {
  // Requires two nodes, the west ("this") & the east ("east").
  return this.constructor.constructNode(
    this.ne.se,
    east.nw.sw,
    this.se.ne,
    east.sw.nw,
  );
}

function centerVerticalNode(south) {
  // Requires two nodes, the north ("this") & the south ("south").
  return this.constructor.constructNode(
    this.sw.se,
    this.se.sw,
    south.nw.ne,
    south.ne.nw,
  );
}

function centerCenterNode() {
  // Like center node, but one more iteration.
  return this.constructor.constructNode(
    this.nw.se.se,
    this.ne.sw.sw,
    this.sw.ne.ne,
    this.se.nw.nw,
  );
}
```

A complication with this approach is that we'd have to create an entirely new function just to break apart these nine auxillary squares and get the portion we need to assemble the blue center square.

When constructing the original node, we can avoid breaking down the subgrids of each nine grids, and instead creating each of the four center quadrant grid of the blue grid.

Since the center blue grid has four quadrants, we can take the four surrounding auxillary grids for each quadrant, use our construct function to create our center grid, and then combine all these four quadrants together to form the final blue grid. Isn't that neat!

```javascript
// Third version.
function evolveNode(node) {
  if (node.level < 2) throw new Error('Current level cannot be less than 2.');
  if (
    !(
      this.nw instanceof Node &&
      this.ne instanceof Node &&
      this.sw instanceof Node &&
      this.se instanceof Node
    )
  )
    throw new Error('Current node cannot be at depth 1.');

  let resultCenterNode;
  if (node.level === 2) {
    // Evolve via simple implementation.
  } else {
    const n00 = node.nw.centerNode();
    const n01 = node.nw.centerHorizontalNode((east = this.ne));
    const n02 = node.ne.centerNode();
    const n10 = node.nw.centerVerticalNode((south = this.sw));
    const n11 = node.centerNodeNode();
    const n12 = node.ne.centerVerticalNode((south = this.se));
    const n20 = node.sw.centerNode();
    const n21 = node.sw.centerHorizontalNode((east = this.se));
    const n22 = node.se.centerNode();

    const center_nw = constructNode(
      evolveNode(n00),
      evolveNode(n01),
      evolveNode(n10),
      evolveNode(n11),
    );

    const center_ne = constructNode(
      evolveNode(n01),
      evolveNode(n02),
      evolveNode(n11),
      evolveNode(n12),
    );

    const center_sw = constructNode(
      evolveNode(n10),
      evolveNode(n11),
      evolveNode(n20),
      evolveNode(n21),
    );

    const center_se = constructNode(
      evolveNode(n11),
      evolveNode(n12),
      evolveNode(n21),
      evolveNode(n22),
    );

    resultCenterNode = constructNode(
      center_nw.centerNode(),
      center_ne.centerNode(),
      center_sw.centerNode(),
      center_se.centerNode(),
    );
  }

  return resultCenterNode;
}

function centerNode() {
  return this.constructor.constructNode(
    this.nw.se,
    this.ne.sw,
    this.sw.ne,
    this.se.nw,
  );
}

function centerHorizontalNode(east) {
  // Requires two nodes, the west ("this") & the east ("east").
  return this.constructor.constructNode(
    this.ne.se,
    east.nw.sw,
    this.se.ne,
    east.sw.nw,
  );
}

function centerVerticalNode(south) {
  // Requires two nodes, the north ("this") & the south ("south").
  return this.constructor.constructNode(
    this.sw.se,
    this.se.sw,
    south.nw.ne,
    south.ne.nw,
  );
}

function centerCenterNode() {
  // Like center node, but one more iteration.
  return this.constructor.constructNode(
    this.nw.se.se,
    this.ne.sw.sw,
    this.sw.ne.ne,
    this.se.nw.nw,
  );
}
```

# Reducing Time

## Memoization

We can cache each result of `evolveNode()` so everytime we reach the same parameters, return the cached result from a hash table.

To visualize the significance of this, imagine our pattern evolves in a circular loop, arriving at its original configuration in N steps. If we cache each N iteration, we can return the result instantly for any future iterations ("exploding effect").

```javascript
// A simple demonstration.
const cache = {
  // [grid]: centerGrid, or more specifically:
  // [node]: evolve(node)
};
```

However, hash tables cannot "hash" a node, since it only hash primitives (int, float, etc.) + strings.
Therefore, we need to convert a grid to a "hash", and ensure that it is unique to that grid.

The simplest approach is to use the pointer address, since our quadtree only has **one** instance of each grid, so all pointers pointing to it will have the exact same address. But, since the center nodes were originally mis-aligned with the original center node, they will result in different patterns, and thus different hashes. To alleviate this, we can make our hash a **combination** of the subnodes.

In my implementation in Typescript, it's much easier to use a randomized ID, so I opted for UUIDv4. Of course, as long as your hash is as unique as possible, any implementation will work.

## Achieving Hyperspeed

Instead of grabbing the centers, why don't we just call `evolveNode()`?
Wouldn't it just increase our time complexity? Well, yeah!

But at the same time, we're using memoization, so we're caching significantly more since we're evolving twice. This is the key to hyperspeed.

For a 8x8 node, we evolve nine 4x4 nodes, then evolve those. Two evolutions.
For a 16x16 node, we evolve nine 8x8 nodes, then evolve those. Since we established that the 8x8 nodes will have two evolutions, then we'll essentially achieve four evolutions.

In summary, at each higher depth, we **double** the evolutions, all of which is cached immediately!

```javascript
// Fourth version.
function evolveNode(node) {
  if (node.level < 2) throw new Error('Current level cannot be less than 2.');
  if (
    !(
      this.nw instanceof Node &&
      this.ne instanceof Node &&
      this.sw instanceof Node &&
      this.se instanceof Node
    )
  )
    throw new Error('Current node cannot be at depth 1.');

  let resultCenterNode;
  if (node.level === 2) {
    // Evolve via simple implementation.
  } else {
    const n00 = node.nw.centerNode();
    const n01 = node.nw.centerHorizontalNode((east = this.ne));
    const n02 = node.ne.centerNode();
    const n10 = node.nw.centerVerticalNode((south = this.sw));
    const n11 = node.centerNodeNode();
    const n12 = node.ne.centerVerticalNode((south = this.se));
    const n20 = node.sw.centerNode();
    const n21 = node.sw.centerHorizontalNode((east = this.se));
    const n22 = node.se.centerNode();

    const center_nw = constructNode(
      evolveNode(n00),
      evolveNode(n01),
      evolveNode(n10),
      evolveNode(n11),
    );

    const center_ne = constructNode(
      evolveNode(n01),
      evolveNode(n02),
      evolveNode(n11),
      evolveNode(n12),
    );

    const center_sw = constructNode(
      evolveNode(n10),
      evolveNode(n11),
      evolveNode(n20),
      evolveNode(n21),
    );

    const center_se = constructNode(
      evolveNode(n11),
      evolveNode(n12),
      evolveNode(n21),
      evolveNode(n22),
    );

    resultCenterNode = constructNode(
      evolveNode(center_nw),
      evolveNode(center_ne),
      evolveNode(center_sw),
      evolveNode(center_se),
    );
  }

  return resultCenterNode;
}

function centerNode() {
  return this.constructor.constructNode(
    this.nw.se,
    this.ne.sw,
    this.sw.ne,
    this.se.nw,
  );
}

function centerHorizontalNode(east) {
  // Requires two nodes, the west ("this") & the east ("east").
  return this.constructor.constructNode(
    this.ne.se,
    east.nw.sw,
    this.se.ne,
    east.sw.nw,
  );
}

function centerVerticalNode(south) {
  // Requires two nodes, the north ("this") & the south ("south").
  return this.constructor.constructNode(
    this.sw.se,
    this.se.sw,
    south.nw.ne,
    south.ne.nw,
  );
}

function centerCenterNode() {
  // Like center node, but one more iteration.
  return this.constructor.constructNode(
    this.nw.se.se,
    this.ne.sw.sw,
    this.sw.ne.ne,
    this.se.nw.nw,
  );
}
```

## The Beauty of Hashlife

Despite how difficult the algorithm may pose to be at first, especially when arriving at these properties unique to the Game of Life, one may ponder at just how simple & elegant the final solution is.

It's a testament to the simplicity of recursion-- iterating over itself through smaller and smaller subtasks until we arrive at a solution. By allowing our algorithm to divide the work to smaller pieces, we can repeat repetitive work (such as applying the Conway's rules) to multiple smaller subgrids, re-assembling it to the original grid.

Moreover, it's astonishing how by just adding one more `evolveNode()` to our recursive function, we can dramatically increase the rate of iterations, which is only beneficial since we cache everything into memory.

It's like trying to build a gigantic Lego set from the ground-up, focusing on the fundamental pieces we know and love, and tackling a large feat through this foundation. HashLife is a brilliant takeaway to how we achieve success through formidable tasks by breaking down such tasks to more managable pieces.

There are so many implementation details we haven't discussed:

- How do you expand the quadtree to fit a large configuration?
- How do you retrieve a particular cell from the quadtree structure?
- How do you retrieve all cells from the quadtree structure?
- How do you set a particular cell from the quadtree structure?
- How do you move to the Nth step?

But alas, this article is already too exhaustive, and it's up to you to discover these solutions yourself. To see the full code, you can check out my [Github repo](https://github.com/sweeneyngo/seagull). Again for those wondering, if you'd like to play & experiment with Conway's Game of Life with the HashLife implementation, feel free to visit the [web application](https://www.ifuxyl.dev/seagull). You can see it in full action by changing the step size (or, speed) through the top-bar.

However, as mentioned in the beginning, Hashlife has an unbearably slow start before it begins its exploding period. Moreover, patterns with random growth are not compatible with Hashlife because the algorithm fails to cache any repeating patterns.

# Sources

All resources, whether for learning or information, are sourced here. Most of the images & diagrams I've used can be found through these websites. Please take a look at them! Without the wealth of knowledge from these articles, I wouldn't have arrived at the solution for this particular project.

HashLife at Official Wikipedia -- [https://en.wikipedia.org/wiki/Hashlife](https://en.wikipedia.org/wiki/Hashlife)

HashLife at Official LifeWiki -- [https://conwaylife.com/wiki/HashLife](https://conwaylife.com/wiki/HashLife)

An Algorithm for Compressing Time and Space -- [https://www.drdobbs.com/jvm/an-algorithm-for-compressing-space-and-t/184406478](https://www.drdobbs.com/jvm/an-algorithm-for-compressing-space-and-t/184406478)

HashLife by ninguem -- [https://www.dev-mind.blog/hashlife/](https://www.dev-mind.blog/hashlife/)

Get a Life by Ben Lynn -- [https://xenon.stanford.edu/~blynn/haskell/life.html](https://xenon.stanford.edu/~blynn/haskell/life.html)

--

You've reached the end, thank you for reading.
To stay notified, consider checking out my [RSS](https://ifuxyl.dev/rss.xml) to be notified of articles like this-- it may be worth your time!

Have a comment, question, or an ask? Feel free to [email](mailto:sweeneyngo@proton.me) me!
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Achieving Freedom in Music]]></title>
            <link>https://ifuxyl.dev/blog/achieving-freedom-in-music</link>
            <guid>https://ifuxyl.dev/blog/achieving-freedom-in-music</guid>
            <pubDate>Fri, 30 Aug 2024 00:00:00 GMT</pubDate>
            <description><![CDATA[Achieving complete independence with music, avoiding subscriptions & pricing altogether.]]></description>
            <content:encoded><![CDATA[
I have an unhealthy obsession with collecting things -- music is no exception. In fact, I find myself picking up new genres and artists that catch my eye. After a few hours, I've stashed away every song, live show, and/or low fidelity recording I can find in their discography.

This was the case with an artist I'm deeply fond of: [Abu-se-ken](https://x.com/kenkoudaiichine) (è™»ç€¬çŠ¬), or simply Abuse. Without him, I doubt I would have cemented my mark in Internet history with my most widely-acclaimed cover, [dogdog ft. Rouon Aro](https://www.youtube.com/watch?v=CBTejIVwlbE).

![Abu-se-ken](/images/abuse.png)

However, I was sick of dealing with the devil; it's inexcusably expensive to buy subscriptions to streaming services like Spotify or Apple Music just to listen to my favorite artists. Having exposure, whether through official streaming or not, is often the best way to get more sales. I mean, just look at TikTok!

Also, audiophiles & music fans can unanimously agree that the recommendation system of Spotify & Apple Music doesn't meet the user's needs. It suffers from a strange "tunneling" effect, where artists you listen to are merely regurgitated back into your feed, with only a handful of new artists appearing in your Discover tab based on local listening & somewhat adjacent genres.

Nowadays, I've developed a system that completely eliminates all streaming services from my life, relying only on a self-curated playlist, alternative applications, options to buy music.

It's important to note that I am by no means an expert on collecting music, nor am I claiming that my method is the best way to find and share music. I'm simply explaining my thought process & workflow in the hopes that you'll learn something new that you didn't know before!

## Finding Your Motive

First, it helps to consider how important achieving freedom is to you.
How often do you listen to music? Are you happy with the current prices of your monthly subscriptions? Maybe you're not aware of alternatives and are curious about the possibilities.

Factors such as the obscurity of your favorite artists, the amount of time you spend listening, the availability of music on different devices, etc. are all important to consider when thinking about this topic.

For me, my breaking point was the lack of awareness of emerging trends & artists due to the poor recommendations I was getting from Spotify. If I had stayed loyal to that platform, I wouldn't have curated the music taste I have today. Artists like [Patricia Taxxon](https://patriciataxxon.bandcamp.com/), [Jane Remover](https://janeremover.bandcamp.com/), or [xaev](https://xaev.bandcamp.com/) would never have been able to make a significant impact on my life, and the feeling of not knowing the larger than life world of music outside of my own circle was soul crushing.

I recommend that everyone should take my suggestions with a grain of salt. I encourage anyone who is skeptical to try it out yourself and see what your motive is.

However, if you're someone who (1) doesn't have disposable income to spend on monthly subscriptions, (2) is an avid supporter of less-popular platforms, or (3) prioritizes digital freedom, then this article may be useful to you.

For those who are still unsure, I've included a rating system of one to three asterisks based on how morally dubious the solution is.

## Searching Better Alternatives (\*)

When considering other alternatives, the first thing I look at is how widely available the music is on that platform. For more popular "radio-friendly" music, this is less of an issue as the publishing label/artist will ensure that their song/LP is available on all platforms.

For more obscure/independent artists, different platforms have different advantages for them, and I'll give a brief introduction to each:

- [Youtube](https://music.youtube.com/): Easily the most accessible platform, fostering an "anyone can create" mentality that paves the way for emerging artists, producers, and mixers alike. I was able to make music by creating covers, and it was thanks to Youtube that I was given an opportunity to build a following. Even if you don't use Youtube Music, the main platform is still amazing in its own right. Don't underestimate its top-notch recommendations & vast network of many genres/artists.

- [Bandcamp](https://bandcamp.com/): If you've ever wanted to support local artists, you may have heard of Bandcamp. Despite its reputation as a shopping platform, Bandcamp has a dense catalog of new artists, trends and recommendations to check out. In addition, Bandcamp is transparent when it comes to different file formats (supports FLAC, OGG, WAV natively) and allows you to maintain your own catalog through its own playback service. An underrated feature of Bandcamp is its follower/following social network, which allows you to easily see people's new purchases, reviews, and listens, which is a much better recommendation system on its own. Some artists even allow users to listen to full LPs and EPs for free, and there's an option to donate to your favorite artists through Bandcamp, a feature missing from other streaming platforms. A common drawback, however, is that some artists/labels don't release their music on Bandcamp, limiting its availability. My recommendation is to limit Bandcamp as a side option for finding music, as it's most effective for niche and/or new artists.

- [Soundcloud](https://soundcloud.com/): While Soundcloud has a somewhat controversial role in the media, it is undeniably a valuable resource for finding music. Most indie artists got their start on Soundcloud, and with its easy barrier to entry, anyone can produce and release music on Soundcloud, diversifying the amount of music you can find. For covers, flips, and/or mixes, Soundcloud is your oyster. Not to mention, Soundcloud's recommendations are oddly effective, and it's a strong competitor to even Spotify.

Although I've reviewed these options separately, I often use a combination of all three in my daily life, picking new songs from each, so don't limit yourself to just one.

To aid your search for more music, I would recommend considering [Last.fm](https://www.last.fm/about/trackmymusic) for tracking your music & seeing others' listens, [RYM](https://rateyourmusic.com/) to see anonymous reviews of all things music, and if you're willing to sift through the cesspool, [4chan's /mu/](https://boards.4chan.org/mu/).

A tool that I found useful for discovering genres was [Music Map](https://www.music-map.com/), which may be worth exploring!

## Migrating to Self-Curation (\*)

Let's say for an ideal citizen, they purchase a LP they really enjoy from Bandcamp, and now they have the digital files in WAV to listen for free. While Spotify & Apple Music allow individuals to listen to music offline through their local library, I would recommend shifting away from these softwares and use open-source alternatives to catalog your music.

A lovely person by the name of Marcika was able to document how they were able to upload their music to a [portable MP3 player](https://www.youtube.com/watch?v=CNFgFbQONJg), which is definitely an option for those who are willing to live frugally. The video also goes more in-depth in some alternatives that I won't mention in this article, so it's worth checking out, especially if you're interesting in burning CDs, listening on a Mac, or ripping music through other means.

For most people with PCs, I recommend [foobar2000](https://www.foobar2000.org/). For full theming support, it's heavily advised to opt for the 32bit version, not the 64bit one. At the time of writing, I've been an active user of this software for 6-7 months, and I'm utterly floored by its compatibility & features.

- Built-in tagging support: Have you ripped music files from unofficial sources? Missing album titles, out of order and/or incorrect information? Simply edit a song or entire albums in foobar and keep it in your files indefinitely. It's crazy how easy it is to edit your files with this software, when the alternative is to download some obscure third-party software with fewer options than foobar.
- Direct folder-library UI: Most people will keep their music in a dedicated music folder, which is already provided in most versions of Windows + Linux. foobar, by default, supports the native folder in the OS, and allows you to freely navigate your directory through the application. It supports sorting by album, artist, alphabetically, and by year, and with the display of album art, a local rating system, visualizations, EQ, and smart search, you will find yourself comfortably browsing through your music with ease.
- Custom theming: If you've ever been dissatisfied with the appearance of foobar, you have the freedom to customize the look and feel of it, from the layout, to the colors, to even custom scripts. Personally, I use [Ottodix's Eole theme](https://github.com/Ottodix/Eole-foobar-theme), which elevates the user experience to the next level, and is my primary choice for modernizing the software.

To give you a little taste, here is a screenshot of my all-time favorite artist, [Porter Robinson's Nurture](https://rateyourmusic.com/release/album/porter-robinson/nurture/) on foobar2000:

![Screenshot of Porter Robinson's Nurture](/images/porter.png)

There is something magical about owning your own music, and keeping your listening space as minimal as possible. No distractions, no ads, no feeds.

## Acquiring Music via Soulseek (\*\*)

If you can't find the music you're looking for, and you want the ability to listen to your favorite artists, I don't blame you. Most music can't geographically pass through various countries, but I want to introduce you to a client software available for Windows, Mac, and Linux called [Soulseek](https://www.slsknet.org/news/node/1).

As mentioned in its [About](https://www.slsknet.org/news/node/680), it's "ad-free, spyware-free" and is simply a file-sharing network with connected peers.

To put it simply, let's say you're looking for a particular rare EP in produced in 1993, and you couldn't find it through the official sources I mentioned above. 9 times out of 10, someone else may have the files for that EP, and is sharing it publicly through Soulseek. By connecting to this client, you're now free to explore the music shared by thousands of avid users. With enough dedication, you'll be able to find not only the full list of songs, but also multiple variations with different file formats.

Can it illegal? Yes, absolutely, if you endorse sharing of copyrighted music. I encourage everyone to stick to non-copyrighted music/works to avoid any legal issues with copyright holders.

As for the sharing of music, you will bear responsibility of ensuring you don't download malware or viruses, but considering the nature of the Soulseek community, which is outwardly generous & pro-sharing, it is extremely unlikely you will encounter a virus. To be safe, check the file format of your download (safe: MP3, OGG, WAV, FLAC) and ensure you're not downloading an executable, for instance.

Remember to be an active participant if you decide to use Soulseek: always share, never leech. There is no penalty, but keep in mind that you can be banned by others if they see that you haven't shared any music of your own. Soulseek wouldn't exist without its users after all!

## Acquring Music through yt-dlp (\*\*)

If you are able to find the music through the official sources, but there is no way to download it to your local library, there is a solution for this as well.

You may know about online services like Youtube-MP3, but these websites are unreliable, slow, and sometimes can even be more dangerous than you may think.

A better way to download music through official sources is a command-line interface software called [yt-dlp](https://github.com/yt-dlp/yt-dlp). Although it's known for downloading Youtube videos (e.g. videos, music, films), it is constantly being updated to expand to other websites, such as Twitter/X, Soundcloud, and more. To see a complete and comprehensive list of supported websites, I recommend visiting [this page](https://github.com/yt-dlp/yt-dlp/blob/master/supportedsites.md).

For installation, follow the instructions listed in their [README](https://github.com/yt-dlp/yt-dlp?tab=readme-ov-file#installation). Personally, I recommend using a package manager if your OS supports this & you're comfortable with it. Otherwise, the binary standalone executable works fine out-of-the-box. It's recommended to download ffmpeg + ffprobe for videos if you'd like to use yt-dlp for that purpose as well.

For all intents and purposes, look into the [official Wiki](https://github.com/yt-dlp/yt-dlp/wiki/Installation) if you have any questions about usage, customization, and installation.

Again, keep in mind that it is a roundabout method to scrape a website for content, rather than visiting their official APIs. Therefore, I don't _necessarily_ recommend this option, just because you can experience throttling or even a soft ban from the service.

## Transfering Music to Devices (\*)

Once you've found a workflow that works for you, you may wonder if there are ways to migrate your files to your devices. For example, most people don't just listen to music on their PCs, but they also like the availability of the music on their smartphones, tablets, etc.

In the case of Spotify and Apple Music, all the music you've saved is essentially stored on an account basis, but in the case of the methods we've mentioned, it's strictly kept on physical local storage.

The solution is to be able to transfer files across different devices and "sync" between your devices without relying on accounts + permissions.

For some, this may be a better alternative since you don't have to rely on creating accounts that put you at risk of overreliance on third party platforms & data breaches, so it's worth keeping in mind.

There are many ways to transfer files, from [OneDrive](https://onedrive.live.com/login/), [Dropbox](https://www.dropbox.com/), [Google Drive](https://www.google.com/drive/), and even open-source file sharing methods like [Catbox](https://catbox.moe/). Honestly, it's up to your needs which option you choose, since the advantages of each are relatively the same.

Of course, there will be storage limits that are specific to each one, and as such you will have to pay for more storage if you need it, so I'll discuss a software that has worked for me for free: [Syncthing](https://syncthing.net/).

Given two devices, Syncthing is able to establish a working connection between them by connecting to the local server and allowing the user to share a file/folder via the server.

In other words, you can share your music folder on your PC, connect your iOS/Android device to the Syncthing server, and watch your files automatically transfer to your device without any hassle. In Syncthing's own words: "Your data is your data, and you deserve to choose where it's stored, whether it's shared with third parties, and how it's transferred over the Internet."

A common pattern you may have noticed in these recommendations is that they are not exclusively for sharing music. This is true! You can easily extend your experience with this handpicked set of applications to other important files, documents, or videos you may have lying around.

You can even authenticate your session, close the server whenever you want, and share multiple folders. Personally, I've had success using Syncthing to sync my Obsidian vault, pictures I've taken with my phone, and videos I've produced. It's really as easy as it sounds, and far better than any alternative I've come across. Please give it a try!

## My Workflow

For me, I frequently browse Youtube Music for streaming music, with the occasional visit to Bandcamp + Soundcloud for interesting stuff. After I buy an album from Bandcamp, I'll listen to them at my leisure through foobar2000.

This is what works for me, and of course this article is by no means comprehensive. There is **seriously** a vast world of resources and tools that people have created to make the process of finding your music easier. I hope this was a helpful introduction, and I wish you luck on your music journey!

--

You've reached the end, thank you for reading.
To stay notified, consider checking out my [RSS](https://ifuxyl.dev/rss.xml) to be notified of articles like this-- it may be worth your time!

Have a comment, question, or an ask? Feel free to [email](mailto:sweeneyngo@proton.me) me!
]]></content:encoded>
        </item>
    </channel>
</rss>