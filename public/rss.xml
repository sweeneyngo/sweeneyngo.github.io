<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/">
    <channel>
        <title>ifu's Blog</title>
        <link>https://ifuxyl.dev</link>
        <description>Homebase [to] -- serving articles &amp; blogs, for ifu.</description>
        <lastBuildDate>Thu, 05 Sep 2024 10:41:46 GMT</lastBuildDate>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
        <generator>Feed for Node.js</generator>
        <language>en</language>
        <image>
            <title>ifu's Blog</title>
            <url>https://ifuxyl.dev/favicon.png</url>
            <link>https://ifuxyl.dev</link>
        </image>
        <copyright>All rights reserved 2024, ifu</copyright>
        <item>
            <title><![CDATA[The Hidden Beauty of HashLife]]></title>
            <link>https://ifuxyl.dev/blog/conway-hashlife</link>
            <guid>https://ifuxyl.dev/blog/conway-hashlife</guid>
            <pubDate>Wed, 04 Sep 2024 00:00:00 GMT</pubDate>
            <description><![CDATA[Discovering the iconic algorithm for the popular zero-player game, Conway's Game of Life.]]></description>
            <content:encoded><![CDATA[
I was introduced to Conway's Game of Life from Daniel Shiffman, particularly in his [mini-series](https://youtu.be/tENSCEO-LEc) about cellular automata. For those who are unaware, Conway's Game of Life was the product formed by rules devised by John Horton Conway in 1970. Despite its name, the Game of Life is a "zero-player game" where the game progresses without any player input. If anything, it's more appropriate to call it a "simulation".


Given a 2D grid, each cell can either be alive (1) or dead (0). What determines whether they live or die at each iteration are determined by the rules of the game.

The rules are as follows:
- Any living cell with less than two live neighbours dies ("underpopulation").
- Any living cell with more than three live neighbours dies ("overpopulation").
-  Any dead cell with exactly three live neighbours will come to life.
- All other cells remain the same ("stasis").

![http://natureofcode.com/book/chapter-7-cellular-automata/](https://notes.huy.rocks/posts/img/game-of-life-visual.png)

To initiate the game, a configuration of cells in any shape, form, etc. is placed on the 2D grid. For each generation, the cells apply the above rules, changing their configuration throughout time.

It is undeniably a compelling thought experiment, as it proves that organization can emerge from a universe governed by very simple laws. Our civilization, culture, and species may very well be a result of eons of configurations that seem amorphous in nature, but can form meaningful constructs given a starting point & time.

For my implementation, I've decided to create my own simulation of Conway's Game of Life. The application was written in Typescript + [React](https://react.dev/) and built with [Vite](https://vitejs.dev/).
I've also implemented the main update loop with the [HashLife](https://en.wikipedia.org/wiki/Hashlife) algorithm (quadtrees & memoization), which we will discuss more thoroughly later in this article.

Currently, it supports edit mode, infinite canvas, zoom & pan, pattern import, and  step size & speed. You can play with it yourself through [this link](https://www.ifuxyl.dev/seagull).


![Screenshot of my web implementation](https://i.imgur.com/isjQn9z.png)

Besides the introduction, the crux of this article will focus on Bill Gosper's [HashLife](https://en.wikipedia.org/wiki/Hashlife) algorithm, where we will discuss the definition, properties, implementation, and the hidden beauty that emerges from it.


# What is HashLife?
**Simply put, it is a memoization algorithm to compute long-term fate of a configuration.**
For instance, you can quite easily generate a 6,366,548,773,467,669,985,195,496,000 (6 [octillionth](https://en.wikipedia.org/wiki/Names_of_large_numbers "Names of large numbers")) generation of a [Turing machine](https://en.wikipedia.org/wiki/Turing_machine "Turing machine") in [Life](https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life "Conway's Game of Life").


If I were to give it a more descriptive title, one that explains exactly what it accomplishes, it would be: ["Exploiting Regularities in Large Cellular Spaces"](https://usr.lmf.cnrs.fr/~jcf/m1/gol/gosper-84.pdf).

In all walks of life, redundancy is everywhere. Whether you wake up in the morning to brush your teeth, or meeting up with the same clique of friends, or even communing to work, we carry ourselves through the "ordinary". Our brains can even remember when we've done something again, such as when we encounter a hard math question that we've studied the night before, or learning a new language, and we can use our memory to guide us towards the answer.

Through redundancy, we can achieve memory, and through memory, we can arrive at the solution with less time & resources from the first time we've attempted it.

In computer science, this principle holds true. We use code to automate everything in our lives, because a computer can tolerate the endless repetition of a task. But, if we allow the computer to remember a task, the computer can more efficiently arrive at a solution much like humans.

When iterating through each generation of Conway's Game of Life, there will be some sections of the grid that have recognizable patterns. For example, the Breeder 1 is composed of multiple Gosper glider guns, which can then generate smaller spaceships.

In fact, most large & complex configurations are mostly smaller configurations working in unison, so if we can somehow "remember" how a portion of it changes, we can assemble these changes back up to the large configuration, effectively updating the configuration entirely.

To summarize, we need to:
- Break down a configuration to smaller, recognizable configurations.
- Remember the state of that configuration, and quickly arrive at the changed state of that configuration.
- Reassemble the original configuration through these smaller resulting changes.

For the first step, we will use Quadtrees.
For the second step, we will use memoization. And finally, the last step will be accomplished by using these two strategies to build up to our final solution.

## Algorithm
For a more general overview, the algorithm stores subpatterns (we will refer to them as "subgrids", or even nodes) in a hash table (like a "cache"). Then, we memoize future iterations at various locations on the grid & time.

It works asynchronously â€” at any given moment it will usually have evolved different parts of the pattern through different numbers of generations.

The algorithm doesn't come without its drawbacks. For instance it's a very memory intensive implementation, since it has to potentially create multiple versions of the grid to cache the results. As such it is not suitable for showing a continuous display of the [evolution](https://conwaylife.com/wiki/Evolution "Evolution") of a pattern. Moreover, HashLife performs poorly on highly chaotic patterns, since there is nothing for it to memorize, so switching to other alternatives like [QuickLife](https://conwaylife.com/wiki/QuickLife) are preferred.

We'll first focus on (1) reducing space via Quadtrees, then move to (2) reducing time via memoization. There will also be a section on achieving Hyperspeed using properties discovered through the algorithm's implementation.

# Reducing Space
## Redundancy in Patterns?
After exploring CGOL for some time, you may notice that there are "repeating" configurations (e.g. oscillators + still-lives).
One step further, consider how large patterns can lead to subpatterns that appear in several places, possibly at different times. **This** is what Hashlife answers.

## Quadtree
A quadtree is a tree with exactly four nodes.
Similar to a binary tree, quadtrees are often used for automata + image manipulation.

We can think of a quadtree as quadrants on a 2D grid. When we think of a graph, we know that there are four quadrants that surround the X-Y axis. Think of each quadrant as its own subgraph. From here, each subgraph has its own quadrants, leading to subgraphs within subgraphs, and you get the idea.

We can visualize this example through this:

![Quadtree of a 16x16 grid](https://www.dev-mind.blog/wp-content/uploads/2020/05/quadtree1-1024x839.png)

In quadtrees, graphs/grids are referred to as nodes. Treat every node as it's own "configuration grid". Notice how each node holds a portion of the configuration of its parent node. Each level of the graph decreases by one as you move down the graph:
- For example, a level 1 node is a 2x2 grid.
- For example, a level 2 node is a 4x4 grid.
- For example, a level 3 node is a 8x8 grid.
- Notice that each new level can fit four nodes of the previous level. A level 2 node's 4x4 grid can hold exactly four 2x2 grids, or exactly four level 1 node.
- At level 0, it contains the exact pixel, or 1x1 grid.


## Optimizations

Notice that in the previous representation of our quadtree, many nodes look exactly the same. This is a problem, because it's *exhaustive*-- we're not reusing these nodes, so we're actually increasing our space then decreasing it. Since the naive implementation uses the entire 2D grid to represent our configuration, we're not beating it in memory size. In fact, we store the 2D grid at the root node, **in addition** to the many subnodes under the quadtree. Therefore, we need some way to **compress** the tree so this tree representation can be more viable than a 2D grid.

We'll start by stating some observations from building out the exhaustive version of the quadtree:

**1. In level 0, a 1x1 grid can only be black or white. Therefore, there are only two nodes at level 0.**
- Furthermore, a 2x2 grid can only have 2^4 configurations, so there are only 16 nodes at level 1.
- Formulating this, the number of nodes is 2^(2^k * 2^k), where k is the level.
- Obviously, the number of configurations skyrockets as we move up the graph, but it is important to understand how small & feasible the lower levels are. In fact, we can consider them as "building blocks", or more formally "cardinal nodes".

**2. The number of specific grids occuring is much lower.**
This is true, and we should NOT exhaust all possible grids. Therefore, we can treat the above optimization as a hard limit.

**3. To maximize sharing a common grid, only create one instance of that grid in our quadtree.**
As you may observe from the image, there are 3 out of the 4 quadrants of the 8x8 grid that are exactly the same. If instead of creating a new node for each quadrant, we just simply point to one instance of that subnode, we can significantly decrease the amount of subnodes we create. Moving further, we can keep abusing this principle to decrease the size of our quadtree.

For the application, we can use hashing to map any grid to an existing grid on the quadtree, avoiding creating duplicates.

Below, each level may have subgrids that are already memorized by the previous level. For instance, the level 3 node has **three** subgrids that match the left level 2 node, and **one** subgrid that match the right level 2 node. This is our ideal quadtree-- **tightly compressed**!

![Same original 8x8 grid, but as compressed quadtree.](https://www.dev-mind.blog/wp-content/uploads/2020/05/quadtree2-975x1024.png)


## Why not other implementations?
**Simple implementation**:

At each generation, use the neighbors of a cell to compute the next state.

***Why is this bad?***

It's O(kn), where n is the number of cells. Therefore, as we increase the number of cells, the algorithm will have to update every cell by a constant factor k. So, for sextillion cells, we'd have to make multiple sextillion updates!

Moreover, the representation of our grid is, well a grid! While it is the most intuitive way to represent our problem, there is no room to compress it, **especially** when we're encountering repetition that our grid just doesn't account for. Instead, we want to abuse pointers & caching in our representation, leading to the "quadtree".

*Aside: Why representation is important*:

Representation is key to reducing space.
Remember, space is memory, and our desktop can only handle so much memory.
For instance, "00000000" can be represented as "8#0" which is a smaller string!

For a "*very dumb*" example, if our grid was a 100x100 grid of all zeroes, then we can represent it as (100, 100, 0) instead of a 100x100 grid, reducing our space considerably.

That's why it's so important to focus on **representation**. It allows us to reduce a ridiculous amount of space to a smaller one, which can massively improve performance.

**The Quadtree division**:

![Cardinal directions for the four branches of a node.](https://i.imgur.com/pI93ux2.png)

With this representation, each of the four quadrants represents (nw, ne, sw, se). We can represent each grid as a `Node`, which we will showcase here:

```typescript
class Node {

    /*
     * Four quadrants of a node.
     *
     *      nw, ne,
     *      sw, se
     *
     * At level one, each quadrant is either (0, 1).
     */

    nw: Node | number;
    ne: Node | number;
    sw: Node | number;
    se: Node | number;

    // Current level of the node in the quadtree.
    level: number;

    constructor(
        nw: Node | number,
        ne: Node | number,
        sw: Node | number,
        se: Node | number
    ) {
        this.nw = nw;
        this.ne = ne;
        this.sw = sw;
        this.se = se;

        this.level = 0;

        if (typeof nw === "number" &&
            typeof ne === "number" &&
            typeof sw === "number" &&
            typeof se === "number"
        ) {
            this.level = 1; // 2x2
        }
        else if (
            nw instanceof Node &&
            ne instanceof Node &&
            sw instanceof Node &&
            se instanceof Node
        ) {
            this.level = nw.level + 1;
        }
    }
```

You'll notice that if the quadrants are at level one, they'll be a 1x1 grid of either 0 or 1, so we can represent them as a number rather than an entire Node. This distinction is useful to label each level, which you can see in our constructor.

Once we have the root node of a quadtree, we can now recursively update each level on the quadtree.

For example, given the 4x4 grid, we would have to compute directly on it, wasting time.
Instead, we can segment the 4x4 grid to a "quadtree", breaking it down to smaller chunks.
Then, we can work on the smaller chunks, and reassemble the 4x4 grid with the new updates ("divide-and-conquer").

In other words, we can represent any possible grid of any size down to a series of **canonical blocks** with a fixed set of configurations. For instance, we can choose the 2x2 grid to be our canonical block. Therefore, we consider all the possible 2Ã—2 cell blocks, leading to 16 possible 2Ã—2 blocks. With this, we perform the quadtree division until we reach lots of 2Ã—2 blocks, then reconstruct the original matrixes with the updated versions of those 2x2 blocks.


ðŸŸ¥ **Hold on.** Isn't this no better than just working on the original grid?

Since we will **already know all the possible updates** of 16 2x2 blocks, we can just cache it in memory, and reuse them instead of computing the update ourselves. Therefore, we're working on a substantially smaller, compressed tree rather than the full grid.

```javascript
function evolveNode(node) {

    if (node.level < 2) throw new Error("Current level cannot be less than 2.");
    if (!(
        this.nw instanceof Node &&
        this.ne instanceof Node &&
        this.sw instanceof Node &&
        this.se instanceof Node)
    ) throw new Error("Current node cannot be at depth 1.");

    let resultNode;
	if (node.level === 2) {
		// Evolve via simple implementation.
	}
	else {
		resultNode = constructNode(
            evolveNode(node.nw),
            evolveNode(node.ne),
            evolveNode(node.sw),
            evolveNode(node.se)
        );
	}

    return resultNode;
}
```

ðŸŸ¥**Hold on**. Won't the neighbors of any given node affect that node? In other words, is it feasible to run `evolveNode()` on the quadrants independently if they share neighbors between the quadrants?

Yes the neighbors will affect the node, so we will have to strategize some alternative solutions. The key idea is that **updating the entire node** is impossible without information from other nodes.

*Alternative solutions*:
- Consider the neighbor's contents towards updating a node -> *redundant*
- Pass the neighbor's pointers.
- **Create a center node**. Each result of `evolveNode()` will return a subgrid, one level lower, centered at the original grid. For example, a 8x8 grid will return a 4x4 grid centered at the original 8x8.

**Why doesn't Solution #1 or #2 work?**

We would not be reducing the time if we incorporate all the neighbors when evolving a grid, so we need a solution that evolves a subgrid independently from its neighbors. Therefore, our solution must meet the **original purpose** at all costs.

Moreover, we don't need all of the neighbor's information. We just need enough so that each pixel on the grid has all eight neighbors.

With the third solution, we realize that the maximum possible subgrid that allows all eight neighbors for every cell is the center subgrid. In fact, the simplest subgrid to work on is the center subgrid.

Therefore, we will focus on Solution #3.

**The result of evolve(node) will produce a center subgrid, one level down.**

![Center subgrid inside the original grid](https://i.imgur.com/RijDZAU.png)

When we recurse, each subgrid will calculate its own center grid, which we can see in green.

![Center subgrids recurse to form subgrids](https://i.imgur.com/NhBKBdw.png)

We haven't considered the edges of the center grid, because we simply don't need to! Consider a fixed grid for Conway's Game of Life. On the edges of the grid, these cells cannot be determined, since they lack all eight neighbors to determine whether they can live or not.

To put it more rigorously, we CANNOT determine the result of the edges of the grid without the information found outside of the given grid. Since we are strictly working independently with our grid, we focus on determining the center grid, as we can guarentee the correct result.

When implementing, it's crucial the quadtree accomodates for the entire configuration. If the root node has edge cells that are active, then the tree is not sufficiantly large enough and must expand to accomodate for those cells.

However, notice how we can't construct the blue center grid with the green center grids because they're not completely aligned. Only a quarter of each green center grid fits in the center blue square. We're only capturing the corners of the blue center grid.

Looking closer, it may be feasible to construct the blue square if we found multiple green center grids that outline the perimeter of the blue square. This observation paves the way for the "nine auxillary squares" strategy.

### Nine auxillary squares
![Nine auxillary squares](https://www.dev-mind.blog/wp-content/uploads/2020/05/center_comput.png)

```javascript
// Second version.
function evolveNode(node) {
    if (node.level < 2) throw new Error("Current level cannot be less than 2.");
    if (!(
        this.nw instanceof Node &&
        this.ne instanceof Node &&
        this.sw instanceof Node &&
        this.se instanceof Node)
    ) throw new Error("Current node cannot be at depth 1.");

    let resultCenterNode;
    if (node.level === 2) {
		// Evolve via simple implementation.
	}
    else {
		const n00 = node.nw.centerNode();
		const n01 = node.nw.centerHorizontalNode(east=this.ne);
		const n02 = node.ne.centerNode();
		const n10 = node.nw.centerVerticalNode(south=this.sw);
		const n11 = node.centerNodeNode();
		const n12 = node.ne.centerVerticalNode(south=this.se);
		const n20 = node.sw.centerNode();
		const n21 = node.sw.centerHorizontalNode(east=this.se);
		const n22 = node.se.centerNode();

		resultCenterNode = assembleNineNode(
			evolveNode(n00), evolveNode(n01), evolveNode(n02),
			evolveNode(n10), evolveNode(n11), evolveNode(n12),
			evolveNode(n20), evolveNode(n21), evolveNode(n22)
		);
	}

    return resultCenterNode;
}

function centerNode() {
	return this.constructor.constructNode(
		this.nw.se,
		this.ne.sw,
		this.sw.ne,
		this.se.nw
	);
}

function centerHorizontalNode(east) {
	// Requires two nodes, the west ("this") & the east ("east").
	return this.constructor.constructNode(
		this.ne.se,
		east.nw.sw,
		this.se.ne,
		east.sw.nw
	);
}

function centerVerticalNode(south) {
	// Requires two nodes, the north ("this") & the south ("south").
	return this.constructor.constructNode(
		this.sw.se,
		this.se.sw,
		south.nw.ne,
		south.ne.nw
	);
}

function centerCenterNode() {
	// Like center node, but one more iteration.
	return this.constructor.constructNode(
		this.nw.se.se,
		this.ne.sw.sw,
		this.sw.ne.ne,
		this.se.nw.nw
	);
}
```

A complication with this approach is that we'd have to create an entirely new function just to break apart these nine auxillary squares and get the portion we need to assemble the blue center square.

When constructing the original node, we can avoid breaking down the subgrids of each nine grids, and instead creating each of the four center quadrant grid of the blue grid.

Since the center blue grid has four quadrants, we can take the four surrounding auxillary grids for each quadrant, use our construct function to create our center grid, and then combine all these four quadrants together to form the final blue grid. Isn't that neat!


```javascript
// Third version.
function evolveNode(node) {
    if (node.level < 2) throw new Error("Current level cannot be less than 2.");
    if (!(
        this.nw instanceof Node &&
        this.ne instanceof Node &&
        this.sw instanceof Node &&
        this.se instanceof Node)
    ) throw new Error("Current node cannot be at depth 1.");

    let resultCenterNode;
    if (node.level === 2) {
		// Evolve via simple implementation.
	}
    else {
		const n00 = node.nw.centerNode();
		const n01 = node.nw.centerHorizontalNode(east=this.ne);
		const n02 = node.ne.centerNode();
		const n10 = node.nw.centerVerticalNode(south=this.sw);
		const n11 = node.centerNodeNode();
		const n12 = node.ne.centerVerticalNode(south=this.se);
		const n20 = node.sw.centerNode();
		const n21 = node.sw.centerHorizontalNode(east=this.se);
		const n22 = node.se.centerNode();


		const center_nw = constructNode(
            evolveNode(n00), evolveNode(n01),
            evolveNode(n10), evolveNode(n11)
        );

		const center_ne = constructNode(
            evolveNode(n01), evolveNode(n02),
            evolveNode(n11), evolveNode(n12)
        );

		const center_sw = constructNode(
            evolveNode(n10), evolveNode(n11),
            evolveNode(n20), evolveNode(n21)
        );

		const center_se = constructNode(
            evolveNode(n11), evolveNode(n12),
            evolveNode(n21), evolveNode(n22)
        );

		resultCenterNode = constructNode(
			center_nw.centerNode(), center_ne.centerNode(),
			center_sw.centerNode(), center_se.centerNode()
		);
	}

    return resultCenterNode;
}

function centerNode() {
	return this.constructor.constructNode(
		this.nw.se,
		this.ne.sw,
		this.sw.ne,
		this.se.nw
	);
}

function centerHorizontalNode(east) {
	// Requires two nodes, the west ("this") & the east ("east").
	return this.constructor.constructNode(
		this.ne.se,
		east.nw.sw,
		this.se.ne,
		east.sw.nw
	);
}

function centerVerticalNode(south) {
	// Requires two nodes, the north ("this") & the south ("south").
	return this.constructor.constructNode(
		this.sw.se,
		this.se.sw,
		south.nw.ne,
		south.ne.nw
	);
}

function centerCenterNode() {
	// Like center node, but one more iteration.
	return this.constructor.constructNode(
		this.nw.se.se,
		this.ne.sw.sw,
		this.sw.ne.ne,
		this.se.nw.nw
	);
}
```

# Reducing Time
## Memoization
We can cache each result of `evolveNode()` so everytime we reach the same parameters, return the cached result from a hash table.

To visualize the significance of this, imagine our pattern evolves in a circular loop, arriving at its original configuration in N steps. If we cache each N iteration, we can return the result instantly for any future iterations ("exploding effect").

```javascript
// A simple demonstration.
const cache = {
	// [grid]: centerGrid, or more specifically:
	// [node]: evolve(node)
}
```

However, hash tables cannot "hash" a node, since it only hash primitives (int, float, etc.) + strings.
Therefore, we need to convert a grid to a "hash", and ensure that it is unique to that grid.

The simplest approach is to use the pointer address, since our quadtree only has **one** instance of each grid, so all pointers pointing to it will have the exact same address. But, since the center nodes were originally mis-aligned with the original center node, they will result in different patterns, and thus different hashes. To alleviate this, we can make our hash a **combination** of the subnodes.

In my implementation in Typescript, it's much easier to use a randomized ID, so I opted for UUIDv4. Of course, as long as your hash is as unique as possible, any implementation will work.

## Achieving Hyperspeed
Instead of grabbing the centers, why don't we just call `evolveNode()`?
Wouldn't it just increase our time complexity? Well, yeah!

But at the same time, we're using memoization, so we're caching significantly more since we're evolving twice. This is the key to hyperspeed.

For a 8x8 node, we evolve nine 4x4 nodes, then evolve those. Two evolutions.
For a 16x16 node, we evolve nine 8x8 nodes, then evolve those. Since we established that the 8x8 nodes will have two evolutions, then we'll essentially achieve four evolutions.

In summary, at each higher depth, we **double** the evolutions, all of which is cached immediately!

```javascript
// Fourth version.
function evolveNode(node) {
    if (node.level < 2) throw new Error("Current level cannot be less than 2.");
    if (!(
        this.nw instanceof Node &&
        this.ne instanceof Node &&
        this.sw instanceof Node &&
        this.se instanceof Node)
    ) throw new Error("Current node cannot be at depth 1.");

    let resultCenterNode;
    if (node.level === 2) {
		// Evolve via simple implementation.
	}
    else {
		const n00 = node.nw.centerNode();
		const n01 = node.nw.centerHorizontalNode(east=this.ne);
		const n02 = node.ne.centerNode();
		const n10 = node.nw.centerVerticalNode(south=this.sw);
		const n11 = node.centerNodeNode();
		const n12 = node.ne.centerVerticalNode(south=this.se);
		const n20 = node.sw.centerNode();
		const n21 = node.sw.centerHorizontalNode(east=this.se);
		const n22 = node.se.centerNode();


		const center_nw = constructNode(
            evolveNode(n00), evolveNode(n01),
            evolveNode(n10), evolveNode(n11)
        );

		const center_ne = constructNode(
            evolveNode(n01), evolveNode(n02),
            evolveNode(n11), evolveNode(n12)
        );

		const center_sw = constructNode(
            evolveNode(n10), evolveNode(n11),
            evolveNode(n20), evolveNode(n21)
        );

		const center_se = constructNode(
            evolveNode(n11), evolveNode(n12),
            evolveNode(n21), evolveNode(n22)
        );

		resultCenterNode = constructNode(
			evolveNode(center_nw), evolveNode(center_ne),
			evolveNode(center_sw), evolveNode(center_se)
		);
	}

    return resultCenterNode;
}

function centerNode() {
	return this.constructor.constructNode(
		this.nw.se,
		this.ne.sw,
		this.sw.ne,
		this.se.nw
	);
}

function centerHorizontalNode(east) {
	// Requires two nodes, the west ("this") & the east ("east").
	return this.constructor.constructNode(
		this.ne.se,
		east.nw.sw,
		this.se.ne,
		east.sw.nw
	);
}

function centerVerticalNode(south) {
	// Requires two nodes, the north ("this") & the south ("south").
	return this.constructor.constructNode(
		this.sw.se,
		this.se.sw,
		south.nw.ne,
		south.ne.nw
	);
}

function centerCenterNode() {
	// Like center node, but one more iteration.
	return this.constructor.constructNode(
		this.nw.se.se,
		this.ne.sw.sw,
		this.sw.ne.ne,
		this.se.nw.nw
	);
}
```

## The Beauty of Hashlife
Despite how difficult the algorithm may pose to be at first, especially when arriving at these properties unique to the Game of Life, one may ponder at just how simple & elegant the final solution is.

It's a testament to the simplicity of recursion-- iterating over itself through smaller and smaller subtasks until we arrive at a solution. By allowing our algorithm to divide the work to smaller pieces, we can repeat repetitive work (such as applying the Conway's rules) to multiple smaller subgrids, re-assembling it to the original grid.

Moreover, it's astonishing how by just adding one more `evolveNode()` to our recursive function, we can dramatically increase the rate of iterations, which is only beneficial since we cache everything into memory.

It's like trying to build a gigantic Lego set from the ground-up, focusing on the fundamental pieces we know and love, and tackling a large feat through this foundation. HashLife is a brilliant takeaway to how we achieve success through formidable tasks by breaking down such tasks to more managable pieces.

There are so many implementation details we haven't discussed:
- How do you expand the quadtree to fit a large configuration?
- How do you retrieve a particular cell from the quadtree structure?
- How do you retrieve all cells from the quadtree structure?
- How do you set a particular cell from the quadtree structure?
- How do you move to the Nth step?

But alas, this article is already too exhaustive, and it's up to you to discover these solutions yourself. To see the full code, you can check out my [Github repo](https://github.com/sweeneyngo/seagull). Again for those wondering, if you'd like to play & experiment with Conway's Game of Life with the HashLife implementation, feel free to visit the [web application](https://www.ifuxyl.dev/seagull). You can see it in full action by changing the step size (or, speed) through the top-bar.


However, as mentioned in the beginning, Hashlife has an unbearably slow start before it begins its exploding period. Moreover, patterns with random growth are not compatible with Hashlife because the algorithm fails to cache any repeating patterns.

# Sources
All resources, whether for learning or information, are sourced here. Most of the images & diagrams I've used can be found through these websites. Please take a look at them! Without the wealth of knowledge from these articles, I wouldn't have arrived at the solution for this particular project.

HashLife at Official Wikipedia -- [https://en.wikipedia.org/wiki/Hashlife](https://en.wikipedia.org/wiki/Hashlife)

HashLife at Official LifeWiki -- [https://conwaylife.com/wiki/HashLife](https://conwaylife.com/wiki/HashLife)

An Algorithm for Compressing Time and Space -- [https://www.drdobbs.com/jvm/an-algorithm-for-compressing-space-and-t/184406478](https://www.drdobbs.com/jvm/an-algorithm-for-compressing-space-and-t/184406478)

HashLife by ninguem -- [https://www.dev-mind.blog/hashlife/](https://www.dev-mind.blog/hashlife/)

Get a Life by Ben Lynn -- [https://xenon.stanford.edu/~blynn/haskell/life.html](https://xenon.stanford.edu/~blynn/haskell/life.html)

--

You've reached the end, thank you for reading.
To stay notified, consider checking out my [RSS](https://ifuxyl.dev/rss.xml) to be notified of articles like this-- it may be worth your time!

Have a comment, question, or an ask? Feel free to [email](mailto:sweeneyngo@proton.me) me!
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Achieving Freedom in Music]]></title>
            <link>https://ifuxyl.dev/blog/achieving-freedom-in-music</link>
            <guid>https://ifuxyl.dev/blog/achieving-freedom-in-music</guid>
            <pubDate>Fri, 30 Aug 2024 00:00:00 GMT</pubDate>
            <description><![CDATA[Achieving complete independence with music, avoiding subscriptions & pricing altogether.]]></description>
            <content:encoded><![CDATA[
I have an unhealthy obsession with collecting things -- music is no exception. In fact, I find myself picking up new genres and artists that catch my eye. After a few hours, I've stashed away every song, live show, and/or low fidelity recording I can find in their discography.

This was the case with an artist I'm deeply fond of: [Abu-se-ken](https://x.com/kenkoudaiichine) (è™»ç€¬çŠ¬), or simply Abuse. Without him, I doubt I would have cemented my mark in Internet history with my most widely-acclaimed cover, [dogdog ft. Rouon Aro](https://www.youtube.com/watch?v=CBTejIVwlbE).

![Abu-se-ken](/images/abuse.png)

However, I was sick of dealing with the devil; it's inexcusably expensive to buy subscriptions to streaming services like Spotify or Apple Music just to listen to my favorite artists. Even back then, it was common to download music via Limewire or other P2P software, and while it's heavily frowned upon today, some of my favorite artists support music sharing in order to be accessible + widely available. Having exposure, whether through official streaming or not, is often the best way to get more sales. I mean, just look at TikTok!

Also, audiophiles & music fans can unanimously agree that the recommendation system of Spotify & Apple Music doesn't meet the user's needs. It suffers from a strange "tunneling" effect, where artists you listen to are merely regurgitated back into your feed, with only a handful of new artists appearing in your Discover tab based on local listening & somewhat adjacent genres.

Nowadays, I've developed a system that completely eliminates all streaming services from my life, relying only on a self-curated playlist, modded third-party applications, P2P software, and more.

It's important to note that I am by no means an expert on collecting music, nor am I claiming that my method is the best way to find and share music. I'm simply explaining my thought process & workflow in the hopes that you'll learn something new that you didn't know before!

## Finding Your Motive

First, it helps to consider how important achieving freedom is to you.
How often do you listen to music? Are you happy with the current prices of your monthly subscriptions? Maybe you're not aware of alternatives and are curious about the possibilities.

Factors such as the obscurity of your favorite artists, the amount of time you spend listening, the availability of music on different devices, etc. are all important to consider when thinking about this topic.

For me, my breaking point was the lack of awareness of emerging trends & artists due to the poor recommendations I was getting from Spotify. If I had stayed loyal to that platform, I wouldn't have curated the music taste I have today.  Artists like [Patricia Taxxon](https://patriciataxxon.bandcamp.com/), [Jane Remover](https://janeremover.bandcamp.com/), or [xaev](https://xaev.bandcamp.com/) would never have been able to make a significant impact on my life, and the feeling of not knowing the larger than life world of music outside of my own circle was soul crushing.

It's worth mentioning that the method I'm suggesting can be considered ethically "questionable", and I recommend that everyone take any suggestion with a grain of salt. I encourage anyone who is skeptical to do their research to understand where their morals align with their legal issues.

However, if you're someone who (1) doesn't have disposable income to spend on monthly subscriptions, (2) is an avid supporter of open source, or (3) prioritizes digital freedom over potential moral implications, then this article may be useful to you.

For those who are still unsure, I've included a rating system of one to three asterisks based on how morally dubious the solution is.

## Searching Better Alternatives (*)

When considering other alternatives, the first thing I look at is how widely available the music is on that platform. For more popular "radio-friendly" music, this is less of an issue as the publishing label/artist will ensure that their song/LP is available on all platforms.

For more obscure/independent artists, different platforms have different advantages for them, and I'll give a brief introduction to each:

- [Youtube](https://music.youtube.com/): Easily the most accessible platform, fostering an "anyone can create" mentality that paves the way for emerging artists, producers, and mixers alike. I was able to make music by creating covers, and it was thanks to Youtube that I was given an opportunity to build a following. Even if you don't use Youtube Music, the main platform is still amazing in its own right. Don't underestimate its top-notch recommendations & vast network of many genres/artists.

- [Bandcamp](https://bandcamp.com/): If you've ever wanted to support local artists, you may have heard of Bandcamp. Despite its reputation as a shopping platform, Bandcamp has a dense catalog of new artists, trends and recommendations to check out. In addition, Bandcamp is transparent when it comes to different file formats (supports FLAC, OGG, WAV natively) and allows you to maintain your own catalog through its own playback service. An underrated feature of Bandcamp is its follower/following social network, which allows you to easily see people's new purchases, reviews, and listens, which is a much better recommendation system on its own. Some artists even allow users to listen to full LPs and EPs for free, and there's an option to donate to your favorite artists through Bandcamp, a feature missing from other streaming platforms. A common drawback, however, is that some artists/labels don't release their music on Bandcamp, limiting its availability. My recommendation is to limit Bandcamp as a side option for finding music, as it's most effective for niche and/or new artists.

- [Soundcloud](https://soundcloud.com/): While Soundcloud has a somewhat controversial role in the media, it is undeniably a valuable resource for finding music. Most indie artists got their start on Soundcloud, and with its easy barrier to entry, anyone can produce and release music on Soundcloud, diversifying the amount of music you can find. For covers, flips, and/or mixes, Soundcloud is your oyster. Not to mention, Soundcloud's recommendations are oddly effective, and it's a strong competitor to even Spotify.

Although I've reviewed these options separately, I often use a combination of all three in my daily life, picking new songs from each, so don't limit yourself to just one.

To aid your search for more music, I would recommend considering [Last.fm](https://www.last.fm/about/trackmymusic) for tracking your music & seeing others' listens, [RYM](https://rateyourmusic.com/) to see anonymous reviews of all things music, and if you're willing to sift through the cesspool, [4chan's /mu/](https://boards.4chan.org/mu/).

A tool that I found useful for discovering genres was [Music Map](https://www.music-map.com/), which may be worth exploring!

## Migrating to Self-Curation (*)

Let's say for an ideal citizen, they purchase a LP they really enjoy from Bandcamp, and now they have the digital files in WAV to listen for free. While Spotify & Apple Music allow individuals to listen to music offline through their local library, I would recommend shifting away from these softwares and use open-source alternatives to catalog your music.

A lovely person by the name of Marcika was able to document how they were able to upload their music to a [portable MP3 player](https://www.youtube.com/watch?v=CNFgFbQONJg), which is definitely an option for those who are willing to live frugally. The video also goes more in-depth in some alternatives that I won't mention in this article, so it's worth checking out, especially if you're interesting in burning CDs, listening on a Mac, or ripping music through other means.

For most people with PCs, I recommend [foobar2000](https://www.foobar2000.org/). For full theming support, it's heavily advised to opt for the 32bit version, not the 64bit one. At the time of writing, I've been an active user of this software for 6-7 months, and I'm utterly floored by its compatibility & features.

- Built-in tagging support: Have you ripped music files from unofficial sources? Missing album titles, out of order and/or incorrect information? Simply edit a song or entire albums in foobar and keep it in your files indefinitely. It's crazy how easy it is to edit your files with this software, when the alternative is to download some obscure third-party software with fewer options than foobar.
- Direct folder-library UI: Most people will keep their music in a dedicated music folder, which is already provided in most versions of Windows + Linux. foobar, by default, supports the native folder in the OS, and allows you to freely navigate your directory through the application. It supports sorting by album, artist, alphabetically, and by year, and with the display of album art, a local rating system, visualizations, EQ, and smart search, you will find yourself comfortably browsing through your music with ease.
- Custom theming: If you've ever been dissatisfied with the appearance of foobar, you have the freedom to customize the look and feel of it, from the layout, to the colors, to even custom scripts. Personally, I use [Ottodix's Eole theme](https://github.com/Ottodix/Eole-foobar-theme), which elevates the user experience to the next level, and is my primary choice for modernizing the software.

To give you a little taste, here is a screenshot of my all-time favorite artist, [Porter Robinson's Nurture](https://rateyourmusic.com/release/album/porter-robinson/nurture/) on foobar2000:

![Screenshot of Porter Robinson's Nurture](/images/porter.png)

There is something magical about owning your own music, and keeping your listening space as minimal as possible. No distractions, no ads, no feeds.

## Acquiring Music via Soulseek (**)

If you'd rather avoid purchasing music, and you want the ability to freely listen to your favorite artists, I don't blame you. I want to introduce you to a client software available for Windows, Mac, and Linux called [Soulseek](https://www.slsknet.org/news/node/1).

As mentioned in its [About](https://www.slsknet.org/news/node/680), it's "ad-free, spyware-free" and is simply a file-sharing network with connected peers.

To put it simply, let's say you're looking for a particular EP in produced in 1993, and you couldn't find it through the official sources I mentioned above. 9 times out of 10, someone else may have the files for that EP, and is sharing it publicly through Soulseek. By connecting to this client, you're now free to explore the music shared by thousands of avid users. With enough dedication, you'll be able to find not only the full list of songs, but also multiple variations with different file formats.

Is it illegal? Yes, absolutely, as it endorses the sharing of copyrighted music with little to no restrictions on doing so. You can, of course, obfuscate your identity with a VPN, but consider the following:
- You will be among the 0.01% of the vast majority of people who actively listen to music. As such, the time commitment and resources necessary to crack down on you are too great for the music industry to care about.
- It's an obscure software, so most people are not even aware of its existence, so you're safely under most organizations' radar.

As for the sharing of music, you will bear responsibility of ensuring you don't download malware or viruses, but considering the nature of the Soulseek community, which is outwardly generous & pro-sharing, it is extremely unlikely you will encounter a virus. To be safe, check the file format of your download (safe: MP3, OGG, WAV, FLAC) and ensure you're not downloading an executable, for instance.

Remember to be an active participant if you decide to use Soulseek: always share, never leech. There is no penalty, but keep in mind that you can be banned by others if they see that you haven't shared any music of your own. Soulseek wouldn't exist without its users after all!

## Acquring Music through yt-dlp (**)

If you are able to find the music through the official sources, but there is no way to download it to your local library, there is a solution for this as well.

You may know about online services like Youtube-MP3, but these websites are unreliable, slow, and sometimes can even be more dangerous than you may think.

A better way to download music through official sources is a command-line interface software called [yt-dlp](https://github.com/yt-dlp/yt-dlp). Although it's known for downloading Youtube videos (e.g. videos, music, films), it is constantly being updated to expand to other websites, such as Twitter/X, Soundcloud, and more. To see a complete and comprehensive list of supported websites, I recommend visiting [this page](https://github.com/yt-dlp/yt-dlp/blob/master/supportedsites.md).

For installation, follow the instructions listed in their [README](https://github.com/yt-dlp/yt-dlp?tab=readme-ov-file#installation). Personally, I recommend using a package manager if your OS supports this & you're comfortable with it. Otherwise, the binary standalone executable works fine out-of-the-box. It's recommended to download ffmpeg + ffprobe for videos if you'd like to use yt-dlp for that purpose as well.

For all intents and purposes, look into the [official Wiki](https://github.com/yt-dlp/yt-dlp/wiki/Installation) if you have any questions about usage, customization, and installation.

Again, keep in mind the legality issues of this option, but if that doesn't bother you, then the vast customization, ease-of-use, and highly availability of the software will serve you immensely well in your music acquistion.

## Acquiring Music through Piracy (***)

It is a little misleading; after all, the above methods of acquiring music are a form of piracy, but they are relatively safe options that pose no risk to the user.

It's not recommended to use this method unless you're knowledgable in sailing the seas, and have ways to obfuscate yourself to avoid any danger.

This is more of a last resort for those who can't find the music they're looking for, and want to try exploring other websites dedicated to online piracy. As such, this section will be particularly brief & I encourage anyone who wants to go down this route to do their own research.

It's highly recommended to use a VPN of sorts, and my best recommendation is to use an official one. A strong contender is [ProtonVPN](https://protonvpn.com/), but any VPN of a similar calibre will work fine. We just want to obfuscate our IP when pirating to avoid anyone identifying who we are.

For all things music, and even other resources you may be interested in, a good place to start in [/r/Piracy's Megathread](https://old.reddit.com/r/Piracy/wiki/megathread/music) which comes with the community's own rating on what sources are credible/reliable to minimize risk.

Personally, I've had a comfortable experience with [RuTracker](https://rutracker.org/forum/index.php), and I highly recommend using a torrenting service rather than direct download, as relying on the S/L ratio is a good overall measure.

For torrenting, you'll need a client, so I recommend using [qBittorrent](https://www.qbittorrent.org/) rather than the infamous uTorrent, as it's open-source, safe, and allows you to search public/private sites through the application itself. Technically, the client software doesn't really matter too much, though.

## Transfering Music to Devices (*)

Once you've found a workflow that works for you, you may wonder if there are ways to migrate your files to your devices. For example, most people don't just listen to music on their PCs, but they also like the availability of the music on their smartphones, tablets, etc.

In the case of Spotify and Apple Music, all the music you've saved is essentially stored on an account basis, but in the case of the methods we've mentioned, it's strictly kept on physical local storage.

The solution is to be able to transfer files across different devices and "sync" between your devices without relying on accounts + permissions.

For some, this may be a better alternative since you don't have to rely on creating accounts that put you at risk of overreliance on third party platforms & data breaches, so it's worth keeping in mind.

There are many ways to transfer files, from [OneDrive](https://onedrive.live.com/login/), [Dropbox](https://www.dropbox.com/), [Google Drive](https://www.google.com/drive/), and even open-source file sharing methods like [Catbox](https://catbox.moe/). Honestly, it's up to your needs which option you choose, since the advantages of each are relatively the same.

Of course, there will be storage limits that are specific to each one, and as such you will have to pay for more storage if you need it, so I'll discuss a software that has worked for me for free: [Syncthing](https://syncthing.net/).

Given two devices, Syncthing is able to establish a working connection between them by connecting to the local server and allowing the user to share a file/folder via the server.

In other words, you can share your music folder on your PC, connect your iOS/Android device to the Syncthing server, and watch your files automatically transfer to your device without any hassle. In Syncthing's own words: "Your data is your data, and you deserve to choose where it's stored, whether it's shared with third parties, and how it's transferred over the Internet."

A common pattern you may have noticed in these recommendations is that they are not exclusively for sharing music. This is true! You can easily extend your experience with this handpicked set of applications to other important files, documents, or videos you may have lying around.

You can even authenticate your session, close the server whenever you want, and share multiple folders. Personally, I've had success using Syncthing to sync my Obsidian vault, pictures I've taken with my phone, and videos I've produced. It's really as easy as it sounds, and far better than any alternative I've come across. Please give it a try!

## My Workflow

For me, I frequently browse Youtube Music for music, with the occasional visit to Bandcamp + Soundcloud for interesting stuff. I use a combination of yt-dlp + Soulseek if I'm interested in downloading a particular song/artist, and listen to them at my leisure through foobar2000.

This is what works for me, and of course this article is by no means comprehensive. There is **seriously** a vast world of resources and tools that people have created to make the process of finding your music easier. I hope this was a helpful introduction, and I wish you luck on your music journey!

--

You've reached the end, thank you for reading.
To stay notified, consider checking out my [RSS](https://ifuxyl.dev/rss.xml) to be notified of articles like this-- it may be worth your time!

Have a comment, question, or an ask? Feel free to [email](mailto:sweeneyngo@proton.me) me!
]]></content:encoded>
        </item>
    </channel>
</rss>